#ifndef RNG_H_
#define RNG_H_

#define __STDC_FORMAT_MACROS 1

#include <cstdlib>
#include <cstddef>
#include <cinttypes>
#include <cuda.h>
#include "../RNG Logic.cuh"


///=============================================================================
///                      Compiler and Platform Features
///=============================================================================

#define STRUCT(S) typedef struct S S; struct S

#if __GNUC__

#define PREFETCH(PTR,RW,LOC)    __builtin_prefetch(PTR,RW,LOC)
#define unlikely(COND)          (__builtin_expect((COND),0))
#define ATTR(...)               __attribute__((__VA_ARGS__))
#define BSWAP32(X)              __builtin_bswap32(X)

#else

#define PREFETCH(PTR,RW,LOC)
#define unlikely(COND)          (COND)
#define ATTR(...)
__host__ __device__ static inline uint32_t BSWAP32(uint32_t x) {
	x = ((x & 0x000000ff) << 24) | ((x & 0x0000ff00) <<  8) |
		((x & 0x00ff0000) >>  8) | ((x & 0xff000000) >> 24);
	return x;
}

#endif

/// imitate amd64/x64 rotate instructions

__host__ __device__ static inline ATTR(const, always_inline, artificial) uint64_t rotl64(uint64_t x, uint8_t b) {
	return (x << b) | (x >> (64-b));
}

__host__ __device__ static inline ATTR(const, always_inline, artificial) uint32_t rotr32(uint32_t a, uint8_t b) {
	return (a >> b) | (a << (32-b));
}


///=============================================================================
///                               Xoroshiro 128
///=============================================================================

struct Xoroshiro {
	uint64_t lo, hi;

	__host__ __device__ Xoroshiro() noexcept :
		lo(),
		hi() {}
	__host__ __device__ Xoroshiro(const uint64_t value) {
		uint64_t l = value ^ 0x6a09e667f3bcc909ULL;
		uint64_t h = l + 0x9e3779b97f4a7c15ULL;
		l = (l ^ (l >> 30)) * 0xbf58476d1ce4e5b9ULL;
		h = (h ^ (h >> 30)) * 0xbf58476d1ce4e5b9ULL;
		l = (l ^ (l >> 27)) * 0x94d049bb133111ebULL;
		h = (h ^ (h >> 27)) * 0x94d049bb133111ebULL;
		l = l ^ (l >> 31);
		h = h ^ (h >> 31);
		this->lo = l;
		this->hi = h;
	}
	__host__ __device__ static Xoroshiro withState(uint64_t lo, uint64_t hi) noexcept {
		Xoroshiro random;
		random.hi = hi;
		random.lo = lo;
		return random;
	}

	__host__ __device__ inline uint64_t nextLong() {
		uint64_t n = rotl64(this->lo + this->hi, 17) + this->lo;
		uint64_t lh = this->lo ^ this->hi;
		this->lo = rotl64(this->lo, 49) ^ lh ^ (lh << 21);
		this->hi = rotl64(lh, 28);
		return n;
	}

	__host__ __device__ inline int nextInt(uint32_t n) {
		uint64_t r = (this->nextLong() & 0xffffffff) * n;
		if ((uint32_t)r < n) {
			while ((uint32_t)r < (~n + 1) % n) r = (this->nextLong() & 0xffffffff) * n;
		}
		return r >> 32;
	}

	__host__ __device__ inline double nextDouble() {
		return (this->nextLong() >> 11) * 1.1102230246251565E-16;
	}
};

//==============================================================================
//                              MC Seed Helpers
//==============================================================================

/**
 * The seed pipeline:
 *
 * getLayerSalt(n)                -> layerSalt (ls)
 * layerSalt (ls), worldSeed (ws) -> startSalt (st), startSeed (ss)
 * startSeed (ss), coords (x,z)   -> chunkSeed (cs)
 *
 * The chunkSeed alone is enough to generate the first PRNG integer with:
 *   mcFirstInt(cs, mod)
 * subsequent PRNG integers are generated by stepping the chunkSeed forwards,
 * salted with startSalt:
 *   cs_next = mcStepSeed(cs, st)
 */

__host__ __device__ static inline uint64_t mcStepSeed(uint64_t s, uint64_t salt)
{
	return s * (s * 6364136223846793005ULL + 1442695040888963407ULL) + salt;
}

__host__ __device__ static inline int mcFirstInt(uint64_t s, int mod)
{
	int ret = (int)(((int64_t)s >> 24) % mod);
	if (ret < 0)
		ret += mod;
	return ret;
}

__host__ __device__ static inline int mcFirstIsZero(uint64_t s, int mod)
{
	return (int)(((int64_t)s >> 24) % mod) == 0;
}

__host__ __device__ static inline uint64_t getChunkSeed(uint64_t ss, int x, int z)
{
	uint64_t cs = ss + x;
	cs = mcStepSeed(cs, z);
	cs = mcStepSeed(cs, x);
	cs = mcStepSeed(cs, z);
	return cs;
}

__host__ __device__ static inline uint64_t getLayerSalt(uint64_t salt)
{
	uint64_t ls = mcStepSeed(salt, salt);
	ls = mcStepSeed(ls, salt);
	ls = mcStepSeed(ls, salt);
	return ls;
}

__host__ __device__ static inline uint64_t getStartSalt(uint64_t ws, uint64_t ls)
{
	uint64_t st = ws;
	st = mcStepSeed(st, ls);
	st = mcStepSeed(st, ls);
	st = mcStepSeed(st, ls);
	return st;
}

__host__ __device__ static inline uint64_t getStartSeed(uint64_t ws, uint64_t ls)
{
	uint64_t ss = ws;
	ss = getStartSalt(ss, ls);
	ss = mcStepSeed(ss, 0);
	return ss;
}


///============================================================================
///                               Arithmetic
///============================================================================


/* Linear interpolations
 */
__host__ __device__ static inline double lerp(double part, double from, double to)
{
	return from + part * (to - from);
}

#endif /* RNG_H_ */